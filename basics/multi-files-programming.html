<!DOCTYPE HTML>
<html lang="zh-Hans" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++ 多文件编程 - RM-CV Wiki</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom-style.css">
        <link rel="stylesheet" href="../theme/css/custom-font.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">前言</a></li><li class="chapter-item expanded "><a href="../basics/index.html"><strong aria-hidden="true">1.</strong> 基础知识</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/multi-files-programming.html" class="active"><strong aria-hidden="true">1.1.</strong> C++ 多文件编程</a></li></ol></li><li class="chapter-item expanded "><a href="../tools/index.html"><strong aria-hidden="true">2.</strong> 开发环境配置和使用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tools/vscode-cmake-extension.html"><strong aria-hidden="true">2.1.</strong> Visual Studio Code 中 CMake 插件的基本使用</a></li><li class="chapter-item expanded "><a href="../tools/dev-with-vcpkg-cmake-win.html"><strong aria-hidden="true">2.2.</strong> Windows 下使用 vcpkg + CMake 进行开发</a></li></ol></li><li class="chapter-item expanded "><a href="../coding-tips/index.html"><strong aria-hidden="true">3.</strong> 编程技巧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../coding-tips/float-to-string.html"><strong aria-hidden="true">3.1.</strong> C++ 浮点数转为字符串</a></li></ol></li><li class="chapter-item expanded "><a href="../TX2/index.html"><strong aria-hidden="true">4.</strong> TX2 使用笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../TX2/new-to-tx2.html"><strong aria-hidden="true">4.1.</strong> 初识 TX2</a></li><li class="chapter-item expanded "><a href="../TX2/using-proxy.html"><strong aria-hidden="true">4.2.</strong> 在 TX2 上使用代理</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RM-CV Wiki</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MUC-RM-CV/wiki" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/MUC-RM-CV/wiki/edit/main/src/basics/multi-files-programming.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="c-多文件编程"><a class="header" href="#c-多文件编程">C++ 多文件编程</a></h1>
<p>C++ 的初学者通常将所有的代码编写在一个文件内。但随着学识的增长，我们总会接触到许多多文件的项目。那么，多文件能解决什么问题，又有什么好处？</p>
<h2 id="多文件的好处"><a class="header" href="#多文件的好处">多文件的好处</a></h2>
<p>我们先不考虑 C++ 实现多文件的方法。我们只需考虑，如果把代码分区放在不同的文件中，是否会方便我们对于代码的查找、管理和协同工作？</p>
<p>此外，我们知道，C++ 是一门需要编译的语言。假如代码分别放在不同的区块中，是否可以实现在每次修改时，只更新改动了的部分？</p>
<p>带着这两个问题，我们便可以继续接下来的内容。</p>
<h2 id="c-编译链接简介"><a class="header" href="#c-编译链接简介">C++ 编译链接简介</a></h2>
<p>我们先从最熟悉的单文件的情况说起。下面是一个简单的 C++ 源文件，里面有一个 <code>foo</code> 函数和有一个 <code>main</code> 函数。根据经验我们知道，一个 C++ 程序需要有 <code>main</code> 函数才能运行。</p>
<pre><code class="language-cpp">// demo.cpp

int foo(int, int);  // foo 函数的声明

int main() {
    int result = foo(3, 5);
    return 0;
}

int foo(int a, int b) {  // foo 函数的定义
    return 2 * a + b;
}
</code></pre>
<p>我们观察文件发现，<code>main</code> 函数调用了 <code>foo</code> 函数。这不是件理所当然的事。事实上，在 <strong>编译</strong> (compile) 过程中，当编译器遇到 <code>foo(3, 5)</code> 这样的表达式时，会去查看是否存在这样的函数可供使用，也就是查找在之前是否已经出现了函数的声明。</p>
<p>对于这里的 <code>foo(3, 5)</code> 语句来说，编译器就要去查找，是否有一个名为 <code>foo</code> 的函数声明，满足参数为两个 <code>int</code> 型整数的情况；如果没有，就要去查找之前的函数声明中，是否有参数列表中参数类型支持从 <code>int</code> 类型转换而得的 <code>foo</code> 函数。</p>
<p>幸运的是，在这条语句之前，我们有一个这样的函数声明，因此编译器能够通过编译；否则，就会报出 <strong>未定义/未声明标识符</strong> (undefined/undeclared identifier) 的错误。</p>
<p>但是，现在还不能生成最终的可执行程序，因为我们还不清楚 <code>foo</code> 函数的具体定义。编译器会将这个符号加入到 <em>未解决符号表</em> 中。</p>
<p>不过，在这个情况里，编译器接着往下走，就会发现 <code>foo</code> 函数的定义，并将其出现的位置记下来。</p>
<p>如此，编译器就从源代码文件生成了目标文件，之后，将进入<strong>链接</strong> (Linking) 阶段。在这个阶段中，编译器根据未解决符号表，去查找是否具有对应的符号，查找到之后，就将为未解决符号记下符号所在的位置。</p>
<p>在上面的例子中，<code>foo(3, 5)</code> 这个语句将会找到在 <code>main</code> 函数之后定义的 <code>foo</code> 函数，因此被解决。如果没有查找到，将会出现 <strong>未解决的外部符号</strong> (unresolved external symbol) 或者 <strong>未定义引用</strong> (undefined reference) 的错误。</p>
<blockquote>
<p>事实上，我们也可以将函数和声明和函数定义写在一起，比如下面这样。</p>
<pre><code class="language-cpp">// demo.cpp

int foo(int, int) { return 2 * a + b; }

int main() {
    int result = foo(3, 5);
    return 0;
}
</code></pre>
</blockquote>
<p>我们将每一个 C/C++ 源文件称作一个翻译单元 (translation unit)。那么在上述的例子中，我们的翻译单元会提供一个 <code>int foo(int, int)</code> 和一个 <code>int main()</code> 的符号，并且有一个 <code>int foo(int, int)</code> 的符号待解决。经过了链接过程，未解决符号得到了解决，于是就可以生成可执行程序了。</p>
<h2 id="将文件拆开"><a class="header" href="#将文件拆开">将文件拆开</a></h2>
<p>假如 <code>foo</code> 函数是一个经常会被用到的函数。在单文件的情况时，我们每写一个新的程序，都需要将其复制到新的源代码文件中。但有了之前的基础，我们发现，可以将 <code>foo</code> 函数拿出来放进单独的文件中。</p>
<blockquote>
<p>接下来的例子中涉及到通过命令行操作编译器。读者只需要明白操作的目的即可，实际使用中不必要手动输入这些命令。</p>
</blockquote>
<p>下面的 <code>foo.cpp</code> 是一个包含 <code>foo</code> 函数的源代码文件。</p>
<pre><code class="language-cpp">// foo.cpp

int foo(int a, int b) {
    return 2 * a + b;
}
</code></pre>
<p>我们让编译器编译 <code>foo.cpp</code> 生成目标文件 <code>foo.o</code>。</p>
<pre><code class="language-console">$ c++ foo.cpp -c -o foo.o
</code></pre>
<p>不出意外的话，当前目录下会多出一个名为 <code>foo.o</code> 的目标文件。目标文件的内容一般不易为人类所阅读，我们只需要知道，这个目标文件提供了 <code>int foo(int, int)</code> 这样一个符号。</p>
<p>接着，我们的 <code>main.cpp</code> 将会写作下面的样子。</p>
<pre><code class="language-cpp">// main.cpp

int foo(int, int);  // 只需要 foo 函数的声明

int main() {
    int result = foo(3, 5);
    return 0;
}
</code></pre>
<p>同样，我们将 <code>main.cpp</code> 编译为目标文件。这个目标文件提供了 <code>int main()</code> 这样一个符号，但有一个 <code>int foo(int, int)</code> 的符号待解决。</p>
<p>之后，我们将两个目标文件链接起来，期望生成最后的可执行程序 <code>main</code>。很顺利，没有出现未解决符号，可执行文件生成成功。</p>
<pre><code class="language-console">$ c++ main.o foo.o -o main
</code></pre>
<h2 id="预处理指令"><a class="header" href="#预处理指令">预处理指令</a></h2>
<p>在编译之前，编译器会先对代码文件进行预处理。有很多预处理指令，比如 <code>define</code>、<code>include</code>。这些命令通常以 <code>#</code> 开始。</p>
<p>一般来说，<code>define</code> 命令可以用来将代码中的宏名替换为对应的内容。除此之外，<code>define</code> 也可以和 <code>ifndef</code>、<code>ifndef</code> 命令配合起来实现“条件编译”。</p>
<p>比如，下面的代码中，因为 <code>define</code> 过名为 <code>FLAG</code> 的宏 (macro)，因此，<code>ifdef</code> 命令条件为真，<code>#ifdef FLAG</code> 和 <code>#endif</code> 之间的代码将会出现在预处理过的代码中；反之，如果没有定义过 <code>FLAG</code>，则其中的代码将不会出现在预处理的结果中。</p>
<pre><code class="language-cpp">#define FLAG

int foo(int, int);

int main() {
#ifdef FLAG
    foo(3, 4);
#endif
    return 0;
}
</code></pre>
<p><code>ifndef</code> 的作用和 <code>ifdef</code> 相反，即，如果没有定义过相应的宏名，才会满足条件。下面的代码中，<code>#ifndef FLAG</code> 和 <code>#endif</code> 之间的代码不会出现在预处理的结果中。</p>
<pre><code class="language-cpp">#define FLAG

int foo(int, int);

int main() {
#ifndef FLAG
    foo(3, 4);
#endif
    return 0;
}
</code></pre>
<p>而<code>include</code> 命令即为将相应的文件内容复制到当前文件里。没错，就是按照原样复制进来。</p>
<h2 id="头文件"><a class="header" href="#头文件">头文件</a></h2>
<p>在上一节的例子中，我们在 <code>main.cpp</code> 中手动写入了 <code>int foo(int, int);</code> 的声明。但当声明较多时，手动编写或复制仍是比较麻烦的。因此，我们一般要为自己的 <code>foo.cpp</code> 编写相应的头文件 (headers) <code>foo.h</code>。这样，我们只需在 <code>main.cpp</code> 中 <code>include</code> 头文件 <code>foo.h</code> 即可。</p>
<p>现在，目录下有这样三个文件：</p>
<ul>
<li><a href="./assets/1/foo.h">foo.h</a></li>
<li><a href="./assets/1/foo.cpp">foo.cpp</a></li>
<li><a href="./assets/1/main.cpp">main.cpp</a></li>
</ul>
<pre><code class="language-cpp">// foo.h

#ifndef FOO_H
#define FOO_H

int foo(int, int);

inline void func() { return; }  // 内联函数

class A {  // A 类型的声明
    int num;
public:
    A() = default;
    int get_num() {  // 直接写在类中的函数也是内联的
        return this-&gt;num;
    }
    void set_num(int num_) {
        this-&gt;num = num_;
    }
    void add(int m);  // 成员函数的实现也可以放在 cpp 中（类外实现）
};

#endif  // FOO_H
</code></pre>
<p>注意，<a href="./assets/1/foo.h">foo.h</a> 中使用 <code>ifndef</code> 等命令实现了该文件在每个翻译单元中仅会被包含一次。这叫做头文件保护 (header guards)。如果用户在一个源文件中不小心引用了两次头文件，或是包含的若干个头文件中都包含了某个头文件，那么将会出现同一个头文件在一个源文件中被引用多次的情况，即造成了重复声明。</p>
<p>此外，头文件中一般不能包含函数定义。试想，如果包含了函数定义的头文件被多个源代码文件包含，则这些源代码文件编译生成的目标文件中都会出现相同的符号。这会导致链接过程中链接器无法决定该使用哪一个符号。同理，也不应该使用 <code>include</code> 将函数定义的代码直接包含进源代码文件。</p>
<p>不过，实际使用中也会出现需要将一些常用的函数放在头文件中的情况，亦即我们在会在很多源文件中用到这一函数。我们希望这些相同的函数在链接时不会相互冲突，因此，我们需要使用 <code>inline</code> 关键字修饰它。</p>
<p>另一种情况是，我们希望一个函数仅在当前翻译单元可用，而在不同的翻译单元中可能同名但定义不同的函数。这时我们应用 <code>static</code> 关键字修饰它们。</p>
<pre><code class="language-cpp">// foo.cpp

#include &quot;foo.h&quot;

static int f(int a, int b) { return a - b; }

int foo(int a, int b) {
    
    a = f(a, b);

    A inst_1;  // 使用了 foo.h 中的 A 类型，因此需要引用 foo.h
    inst_1.set_num(2 * a);
    inst_1.add(b);

    return inst_1.get_num();
}

void A::add(int n) {
    this-&gt;num += n;
}
</code></pre>
<p>在 <a href="./assets/1/foo.cpp">foo.cpp</a> 中，同样引用了相对应的头文件，这是由于，头文件中可能包含了一些结构或类型的声明，或者包含其他的一些头文件。这时候，需要引用该头文件，否则编译时将会出现未声明符号的问题。</p>
<pre><code class="language-cpp">// main.cpp

#include &quot;foo.h&quot;

static int f(int a, int b) { return a + b; }

int main() {
    int result = foo(2, 3);
    int t = f(4, 5);
}
</code></pre>
<p>最后，<a href="./assets/1/main.cpp">main.cpp</a> 中只需要调用 <a href="./assets/1/foo.h">foo.h</a> 中提供的符号即可。</p>
<p>在编译的时候，分别生成目标文件：</p>
<pre><code class="language-console">$ c++ foo.cpp -c -o foo.o
$ c++ main.cpp -c -o main.o
</code></pre>
<p>再执行链接操作：</p>
<pre><code class="language-console">$ c++ main.o foo.o -o main
</code></pre>
<p>参考资料：</p>
<ul>
<li>https://en.cppreference.com/w/c/language/storage_duration</li>
<li>https://en.cppreference.com/w/cpp/language/storage_duration</li>
</ul>
<h2 id="头文件搜索路径"><a class="header" href="#头文件搜索路径">头文件搜索路径</a></h2>
<p>当使用双引号 <code>&quot;&quot;</code> 包含头文件时，编译器首先查找当前工作目录或源代码目录，然后再在标准位置查找。而使用尖括号 <code>&lt;&gt;</code> 时，编译器将在系统的头文件目录中查找。</p>
<h2 id="构建工具"><a class="header" href="#构建工具">构建工具</a></h2>
<p>上述生成可执行文件 <code>main</code> 的过程，就叫做<strong>构建</strong> (build)。在这个过程中，我们的 <em>目标</em> 是生成可执行程序 <code>main</code>，而这个目标需要 <code>main.cpp</code>、<code>foo.h</code> 以及 <code>foo.cpp</code> 三个文件；其中，<code>main.cpp</code> 和 <code>foo.cpp</code> 又依赖于 <code>foo.h</code> 文件。</p>
<p>更具体地来说，生成可执行程序 <code>main</code> <em>依赖</em> <code>main.o</code> 和 <code>foo.o</code> 两个目标文件，而这两个目标文件，又分别由对应的 <code>cpp</code> 文件生成。假如目标文件对应的 <code>cpp</code> 文件发生了更改（又或者其所包含的头文件发生了更改），都需要重新生成相应的目标文件，才能保证最终链接之后生成的可执行程序是最新的。</p>
<p>不同于曾经的单文件，现在我们要构建一个目标需要多个文件。有两个问题需要解决：</p>
<ul>
<li>每次都需要输入多条命令才能完成编译、链接，而不是一条；</li>
<li>我们希望减少编译的次数，因此需要记录哪些文件发生了更改，只对有必要重新编译的文件编译。</li>
</ul>
<p>如果项目更多、项目之间有依赖关系，则需要输入更多、更复杂的命令，也需要留意更多的文件。如果全由用户来做，很容易出现差错。</p>
<p>构建工具可以帮助我们自动化上述的流程。我们告诉构建工具生成目标需要哪些依赖，构建工具就可以在每次我们需要重新构建目标时，检测需要重新生成的文件，并完成构建流程。</p>
<p>一些 IDE 会有自己的构建工具，但通常把这个过程对用户隐去了。用户将源代码添加进一个“项目”中，IDE 便将其视作生成该项目的依赖。</p>
<h2 id="cmake"><a class="header" href="#cmake">CMake</a></h2>
<p>使用 CMake 这样一个构建管理工具，只需编写一个 <code>CMakeLists.txt</code> 文件，便可以生成用于不同构建工具的脚本。</p>
<h2 id="具体演示"><a class="header" href="#具体演示">具体演示</a></h2>
<p>可以在 <a href="https://gitlab.com/klixr/cpp-multi-file-demo/">gitlab.com/klixr/cpp-multi-file-demo</a> 查看一个具体的示例。</p>
<p>也可通过下边的链接访问上述示例的副本。</p>
<p>假设我们现在有这样一个 C++ 文件 <a href="assets/2/single_file_demo.cpp">single_file_demo.cpp</a>，示例将其拆分成了多文件的形式。</p>
<p><code>Date</code> 库：</p>
<p><a href="assets/2/Date/Date.hpp">Date/Date.hpp</a></p>
<pre><code class="language-cpp">// Date.hpp

// 头文件需要进行保护，目的是避免重复包含

#ifndef DATE_HPP
#define DATE_HPP

// 头文件中不能包含具体的定义
// 由于头文件可能会被多个 cpp （编译单元）包含
// 如果头文件中包含具体的定义，这些编译单元在最后链接过程中，会出现多个重复的符号
// 如果确需在头文件中包含具体函数的定义，需要声明为 inline（内联）

class Date {
    int y;
    int m;
    int d;
    auto is_leap(int year) {
        return (year % 4 ==0 &amp;&amp; year % 100 != 0) || year % 400 == 0;
    }
public:
    // 类的声明中直接书写的函数也属于 inline 函数
    Date(int y_, int m_, int d_) : y(y_), m(m_), d(d_) {}

    // 也可以只写声明，再在 cpp 文件中实现这个函数
    int get_days();
};


#endif // DATE_HPP
</code></pre>
<p><a href="assets/2/Date/Date.cpp">Date/Date.cpp</a></p>
<pre><code class="language-cpp">// Date.cpp

// 由于需要实现 Date.hpp 中声明的函数，需要包含 Date.hpp

#include &quot;Date.hpp&quot;

int Date::get_days()
{
    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (is_leap(this-&gt;y)) {
        days[2] = 29;
    }
    auto cnt = 0;
    for (int i = 1; i &lt; this-&gt;m; ++i) {
        cnt += days[i];
    }
    cnt += this-&gt;d;
    return cnt;
}

</code></pre>
<p><a href="assets/2/Date/CMakeLists.txt">Date/CMakeLists.txt</a></p>
<pre><code class="language-cmake">project(My-Date)

add_library(Date &quot;Date.hpp&quot; &quot;Date.cpp&quot;)
target_include_directories(Date INTERFACE .)
</code></pre>
<p>使用 <code>Date</code> 库：</p>
<p><a href="assets/2/demo.cpp">demo.cpp</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &quot;Date.hpp&quot;

int main() {
    int y, m, d;
    std::cin &gt;&gt; y &gt;&gt; m &gt;&gt; d;
    Date d1(y, m, d);
    std::cout &lt;&lt; d1.get_days();
}
</code></pre>
<p><a href="assets/2/CMakeLists.txt">CMakeLists.txt</a></p>
<pre><code class="language-cmake">project(CPP-Multi-File-Demo)

add_executable(single_file_demo &quot;single_file_demo.cpp&quot;)

# 逐一指明目标 demo 需要的源文件
# add_executable(demo &quot;demo.cpp&quot; &quot;Date/Date.hpp&quot; &quot;Date/Date.cpp&quot;)

# 或者：

# 将 Date 生成为一个 Library
# 并作为子项目引入
# 子目录 Date 中的 CMakeLists.txt 包含生成 Date 这个 library 的目标

add_subdirectory(Date)

add_executable(demo &quot;demo.cpp&quot;)
target_link_libraries(demo Date)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basics/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../tools/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basics/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../tools/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
